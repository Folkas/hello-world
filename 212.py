# -*- coding: utf-8 -*-
"""212.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/TuringCollegeSubmissions/lgrusa-DS.2.1.2/blob/master/212.ipynb

# Module 2: Data Engineering
### Sprint 1: Software Engineering and Reproducible Research
### Subproject 2: Software Testing, Documentation, and Licensing

Welcome to the second lesson of this sprint. This lesson we will be talking about writing unit tests. We will be discussing why we need to test our code and will talk about best testing practices. We will also cover more in depth comments, documentation and software licensing.

---

## Learning outcomes
- You will learn about different software test types
- You will know how to do unit tests
- You will know how to write good comments
- You will able to understand and apply different types of licenses

## Why we need to test code?
As an engineer, you will be writing a lot of code. You will also be reading even more code that your colleagues written. How can you be sure that one simple line of code that you added to a codebase will not break anything? Well, tests should take care of this problem and tell you if the code does not work anymore. One of the main idea that you need to remember is **tests should take care** of mentioned problem. This is because tests are as good ad you our your colleagues write them. So lets talk about how to write good tests.

### Different types of software tests
There are multiple types of tests in the testing world. Different types serves different purposes:

#### Unit tests
As a future data scientist, you will likely work with unit tests most of your testing time. Unit tests are very low level, close to the source of your application. They consist in testing individual methods and functions of the classes, components or modules used by your software. They ensure that changes of one part of the system will not break the rest of it. These tests are usually ran before every major code merge to ensure everything still works. In this lesson you will learn how to write them.

#### Integration tests 
Integration tests verify that different modules or services used by your application work well together. For example, it can be testing the interaction with the database or making sure that microservices work together as expected. These types of tests are more expensive to run as they require multiple parts of the application to be up and running. These tests are usually ran in more complex systems. You might need to write them but it is very unlikely as a data scientist your development environment will usually be a closed one.

#### Functional tests
Functional tests focus on the business requirements of an application. They only verify the output of an action and do not check the intermediate states of the system when performing that action. There is sometimes a confusion between integration tests and functional tests as they both require multiple components to interact with each other. The difference is that an integration test may simply verify that you can query the database while a functional test would expect to get a specific value from the database as defined by the product requirements. Usually functional and integration tests merge into one. You might see integration tests handled as functional and functional as integration ones.

#### End-to-end tests
End-to-end testing replicates a user behavior with the software in a complete application environment. It verifies that various user flows work as expected and can be as simple as loading a web page or logging in or much more complex scenarios verifying email notifications, online payments. End-to-end tests are very useful, but they're expensive to perform and can be hard to maintain when they're automated. It is recommended to have a few key end-to-end tests and rely more on lower level types of testing (unit and integration tests) to be able to quickly identify breaking changes. These tests can also be made by QA. They are really liked by mobile or web developers where user input and interactions with UI is commonly used.

#### Acceptance testing
Acceptance tests are formal tests executed to verify if a system satisfies its business requirements. They require the entire application to be up and running and focus on replicating user behaviors. But they can also go further and measure the performance of the system and reject changes if certain goals are not met. These tests are quite rare in modern software development. They are mostly used when working with strict project requirements. There is a big chance that you will not encounter this type of test in a really long time.

#### Performance testing
Performance tests check the behaviors of the system when it is under significant load. These tests are non-functional and can have the various form to understand the reliability, stability, and availability of the platform. For instance, it can be observing response times when executing a high number of requests, or seeing how the system behaves with a significant of data. Performance tests are by their nature quite costly to implement and run, but they can help you understand if new changes are going to degrade your system. These tests are really important if you want to make sure that your deployed application will work as expected. As you will learn to deploy your trained models to production, you will need to not to forget to test performance of the service.

To read more about different types of software tests you can go to [this](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing) page.

## Unit tests
As mentioned earlier unit tests are the type of software tests you will encounter most. You can have as many unit tests as you believe is needed. Unit tests are cheap (time and resources wise) to run but can bring you a lot of value: they can catch problems before running whole application, they can check if deployed code will work as expected. There is only one downside of these type of tests - they are only as good as you write them. Unit tests are only a part of your code base, they act as you wrote them to. If the test that you wrote will not cover some specific edge case, you will not be protected from failures in the production. Let's see what can and what should you test:

### Basic functions
Imagine that you need to create a function that adds to numbers provided (`a: int, b: int)`:
"""

def sum(a: int, b: int) -> int:
    return a + b

"""You might write test to this function using `assert`:"""

assert sum(1, 2) == 3

"""This test is correct but not really beneficial. The function that you are testing is not that complex and there is a small chance that it will fail. You could even go as far as ignoring writing the test to the `sum` function. On the other hand, imagine that you need to write function that sums all values in list and it uses `sum` function above:"""

def sum_list(a: list) -> int:
    result = 0
    for value in a:
        result = sum(result, value)

    return result

assert sum_list([1, 2]) == 3

"""This is where tests comes in handy: imagine that somewhere in the code base you use `sum_list` function to calculate students in the school (value in list is number of children in the individual class)."""

students_count = sum_list([10, 24, 31, 25])

"""One day you notice that number of students in the schools is quite low. It was actually decreasing for the past sprint. Oddly school is still full and no reports on missing students were made, so you decide to check your code:"""

def sum(a: int, b: int) -> int:
    return b

def sum_list(a: list) -> int:
    result = 0
    for value in a:
        result = sum(result, value)
    return result

print(sum_list([10, 20, 31]))

"""You go and check your `sum` function and notice that it looks different:"""

def sum(a: int, b: int) -> int:
    return b

"""Someone removed `a +` by accident and no one noticed it! What you could have done is wrote test that checks if `sum_list` returns expected value:"""

assert sum_list([1, 2]) == 3

"""A short run of tests would have shown you that mistake was made. Even keeping the `sum` test would have been a good thing. This is a really funny and simple example but believe me it actually happens. These days simple tests costs almost nothing (they run fast and do not require huge computing resources) and they should be ran as frequent as possible. You might not even know that change that you made broke something that your collegue wrote. Tests are here to solve this problem. You should read [this](https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters) blog post on how to write good tests. Code examples are wrote in `C#` but are really straight forward and easily understandable.

Now that you know why and how you need to write tests, you need to watch [this](https://www.youtube.com/watch?v=etosV2IWBF0&ab_channel=MattLayman) video that will show you Python specific code testing examples.

### Testing tools
In the video "Python Testing 101 with pytest" you saw a Python tool called `pytest`. This is a commonly used tool in the Python ecosystem for code testing. Alternatively you can use tool `unittest`. Latter is also loved by Python users but the suggestion is to stick with `pytest` as it has more support from software giants (Google, Facebook) so you will see this tool more often. You can read the discussion on [pytest vs unittest](https://stackoverflow.com/questions/27954702/unittest-vs-pytest) and see other arguments made on this topic. Now you will have to use `pytest` to complete the exercises below.

## Exercises
Now you will need to check your understanding by writing some unit tests using `pytest` tool. First, you will need to install the package using pip:
"""

# Installing pytest using pip
!pip install pytest ipython_pytest

"""As you are working in the notebooks, you also installed tool called `ipython_pytest`. This tool is designed to run pytest inside notebooks. To configure it you will need to run `%load_ext ipython_pytest` one time in the notebook and you will also need to add `%%pytest` at every cell that contains test."""

import ipython_pytest

# Commented out IPython magic to ensure Python compatibility.
# %load_ext ipython_pytest

"""Here is a `class` of school class that has multiple attributes and functions inside:"""

class Class:
    def __init__(self, students_list: list, teacher_name: str) -> None:
        self.__students_list = students_list
        self.__teacher_name = teacher_name
        
    def __str__(self) -> str:
        return f"Teacher of this class is {self.__teacher_name}. There are {len(self.__students_list)} students in the class."
    
    @property
    def students_count(self) -> int:
        return len(self.__students_list)
    
    def add_student(self, student_name: str) -> None:
        if student_name in self.__students_list:
            raise ValueError(f"Student {student_name} is allready in the class!")
        self.__students_list.append(student_name)
        
    def remove_student(self, student_name) -> None:
        self.__students_list.remove(student_name)

model = Class(["Larry", "Amy", "Terrence"], ["Judith"])
model.add_student("Jerry")
model.remove_student("Jerry")
model.add_student("Amy") == "ValueError: Student Amy is allready in the class!"

"""Now you will need to write tests to this class using `pytest`"""

# Commented out IPython magic to ensure Python compatibility.
# %%pytest
# 
# class Class:
#     def __init__(self, students_list: list, teacher_name: str) -> None:
#         self.__students_list = students_list
#         self.__teacher_name = teacher_name
#         
#     def __str__(self) -> str:
#         return f"Teacher of this class is {self.__teacher_name}. There are {len(self.__students_list)} students in the class."
#     
#     @property
#     def students_count(self) -> int:
#         return len(self.__students_list)
#     
#     def add_student(self, student_name: str) -> None:
#         if student_name in self.__students_list:
#             raise ValueError(f"Student {student_name} is already in the class!")
#         self.__students_list.append(student_name)
#         
#     def remove_student(self, student_name) -> None:
#         self.__students_list.remove(student_name)
# 
# model = Class(["Larry", "Amy", "Terrence"], ["Judith"])
# 
# # model.students_count
# def test_students_count_is_correct():
# 
#   assert model.students_count == 3
#     # CHECK IF STUDENTS COUNT IS CORRECT
# 
# def test_can_add_student():
#   assert model.add_student("Jerry") is None
#     # CHECK IF YOU CAN ADD STUDENT
# 
# def test_can_remove_student():
#   assert model.remove_student("Jerry") is None
#     # CHECK IF YOU CAN REMOVE STUDENT
# 
# import pytest 
# def test_can_not_add_duplicate_student():
#   with pytest.raises(ValueError):
#     model.add_student("Amy")
#     # CHECK IF CAN NOT ADD DUPLICATE STUDENT

"""You successfully wrote tests! Good job! Now you have basic understanding on how to write `pytest` tests. You might ask: why I need to use this tool if I only write `asserts`? Well, `pytest` has a lot more in his [sleeves](https://docs.pytest.org/en/stable/contents.html). In the documentation you can find tons of cool stuff that can help you to write *better programs*. Writing tests is a skill that improves with practice, so do not be afraid to write them.

## Comments and documentation
As mentioned in the first lesson of this sprint, writing good and beneficial comments is a part of writing clean and easily readable code. Actually tests are a type of documentation too. Think about it: tests tells you how parts of code should behave. Tests provide information about expected outputs and interactions between different parts of the code base. This is another pro of writing tests - you need to write less comments. However, sometimes you can not avoid writing comments so you need to know why and how to do it. Writing comments and documentation is a really opinionated topic so take provided information with a grain of salt.

### Different types of information
#### Comments
There are many schools on how and when you should write comments but almost all of them agrees that writing comments should also be kept to minimum. Your code should be self explainatory:

```python
### BAD EXAMPLE

def person_information(person: Person):
    # checks if person is male and over 18 years old
    return Person.age > 18 and Person.sex == "male"

### GOOD EXAMPLE

def person_is_adult_male(person: Person) -> bool:
    return Person.age > 18 and Person.sex == "male"
```

It is really hard to illustrate why, how and when you should write comments in one notebook cell, so you should revisit chapter 4 of "Clean Code" book and read it once more. Writing good comments is a skill that also comes with practice so you should not be discouraged when a senior developer tells you to improve the comment that you wrote. If you keep things simple and write clean code, you will need less `#` type comments.

#### Docstrings
You should only write comments where it is hard to express meaning with code itself. Docstrings are a bit different story. Datacamp.com has a really great description of docstring: *Python documentation string or commonly known as docstring, is a string literal, and it is used in the class, module, function, or method definition. Docstrings are accessible from the doc attribute `(__doc__)` for any of the Python objects and also with the built-in `help()` function.* You should not use docstrings as the main source of documentation but it can really help to explain difficult functions in a huge libraries.
Best example of docstring usage might be `fast.ai` library. Fast.ai lets users to read in depth explanation of code using notebooks. It is really convenient for data scientists and all other developers who uses Jupyter as the main dev tool. [Here](https://www.programiz.com/python-programming/docstrings) is a page that has really in depth explanation of the differences between comments and docstrings. The reach of docstrings is usually made by mentioned functions above or by using `Pydoc`. Pydoc is a tool that lets developers to easily access and create code documentation. [Here](https://www.youtube.com/watch?v=URBSvqib0xw) is a video that covers basics of Pydoc (just do not be annoyed by the strange talking lady :D)

It is highly suggested to read [freecodecamp article](https://www.freecodecamp.org/news/code-comments-the-good-the-bad-and-the-ugly-be9cc65fbf83/) about commenting in general. As mentioned earlier code style and commenting are really opinionated topics but there still are main ideas and concepts that most developers agree on.

#### Type hints
You might have noticed strange parts of code in the provided examples. For example: `def sum(a: int, b: int) -> int:`. **a: int**, **->int:** are the type hints. You should always use them as they not only helps to prevent unexpected types of inputs and outputs but they also provide information about your code. See the example below:
```python
def sum_list(a):
    # TAKES LIST AND RETURNS INT TYPE SUM OF LIST
    return int(sum(a))
```
If you know about type hints, you can rewrite this function like this:
```python
def sum(a: list) -> int:
    return int(sum(a))
```

The information that was in the name of the function and in the comment now is in the function itself: there is no need to write `sum_list` as the type of argument shows that the input will be a list. There is no need to write comment that tells that returned value's type will be int, type hints shows you. In [this](https://florimond.dev/blog/articles/2018/07/why-i-started-using-python-type-annotations-and-why-you-should-too/) blog post you can find more examples that illustrates why you should use type hints.

#### README.md PLEASE!
`README.md` file is the core of your project. This documentation file can decide if you project is successful or not. This is even more serious case if the main place that your project is accessible from is page like GitHub. Good readme files commonly share these attributes:
* Have structure
* Have instructions on how to use your project
* Frequently updated
* Easy to read and follow

Here is a cool blog post that explains structure really well: [link](https://bulldogjob.com/news/449-how-to-write-a-good-readme-for-your-github-project). You should always have well written `README` file in your project as it not only shows quality of your work but also provides information that is easy to read and access.

## Licenses
The last topic of this lesson is licenses. Every code line has its own author. This comes with idea that every author has its own opinion and ideas on how his code should be used or distributed. Licensing is a pretty common in our technological world. There are many different types of legal documents that you can use to protect your own code. Mainly there are five different types of Software Licenses:
1. Public Domain
2. GNU/LGPL – GNU Lesser General Public
3. Permissive
4. Copyleft
5. Proprietary

In the open source world of code, most of the code is protected by Public Domain and GNU type licenses. You can read more about these different types [here](https://snyk.io/learn/what-is-a-software-license/). Sometimes it is required that your project has to contain license (creating Python package) but it is always a good practice to have one. The one thing that you must do is to not to breach provided licenses. You can get into serious legal trouble by avoiding provided software or code usage terms. Even datasets have licenses: some are available for commercial usage some are not. If you want to avoid unexpected legal charges you need to learn how to protect your project with license and how to understand and follow provided legal documents when using software or other type of digital medium.

## Exercise
In this lesson's final exercise you will need to port the Tesla factory code from notebook cell to a `.py` file and write tests to it. You will also need to complete initialization of project by creating `README` file. You will also need to generate and add MIT license to your project.
1. Create a GitHub repository. [Here](https://guides.github.com/activities/hello-world/) is a tutorial on how to do it
2. Copy Tesla Fabric code you wrote last lesson and apply two unit tests to it
3. Add Docstrings to selected three functions of `Tesla` class
4. Write clear README file. Follow structure mentioned earlier in the lesson
5. Add Open Source MIT license to your repository https://opensource.org/licenses/MIT
"""

# Commented out IPython magic to ensure Python compatibility.
# #copying Tesla Fabric code and applying 2 unit tests to it 
# 
# %%pytest
# class Tesla:
#     def __init__(self, model: str, color: str, autopilot: bool = False) -> None:
#       self.__unlock_count = 0
#       self.__model = model
#       self.__color = color
#       self.__battery_charge = 99.9
#       self.__is_locked = True
#       self.__seats_count = 5
#       self.__autopilot = autopilot
#       self.__open_doors = "Car is locked!"
#       self.__efficiency = 0.3
# 
#     def welcome(self) -> str:
#         raise NotImplementedError
# 
#     @property
#     def getColor(self) -> str:
#         return self.__color
#     @property
#     def getModel(self) -> str:
#         return self.__model
#     @property
#     def seats_count(self) -> str:
#         return self.__seats_count
# 
#     @seats_count.setter
#     def seats_count(self, new_count: str) -> str:
#         self.__seats_count = new_count
# 
#     def autopilot(self, obsticle: str) -> str:
#         # COMPLETE THE FUNCION
#         if self.__autopilot:
#           return f"Tesla model {self.__model} avoids {obsticle}"
#         return "Autopilot is not available"
#     
#     def unlock(self) -> str:
#       self.__unlock_count = 1
# 
#     def lock(self) -> str:
#       self.__unlock_count = 0
# 
#     def open_doors(self):
#       if self.__unlock_count == 0:
#         return "Car is locked!"
#       else:
#         return "Doors opens sideways"
#         
#     def check_battery_level(self) -> str:
#         return f"Battery charge level is {self.__battery_charge}%"
#     
#     def charge_battery(self) -> str:
#         self.__battery_charge = 100
#         return f"Battery charge level is {self.__battery_charge}%"
#     
#     def drive(self, travel_range: float):
#         battery_discharge_percent = travel_range * self.__efficiency
#         if self.__battery_charge - battery_discharge_percent >= 0:
#           self.__battery_charge -= battery_discharge_percent
#           return f"Battery charge level is {self.__battery_charge}%"
#         else:
#           return "Battery charge level is not sufficient"
# tešla =Tesla("Kiec", "rūžavs")  
# 
# def test_open_doors(): 
#   tešla.unlock()
#   assert tešla.open_doors() == "Doors opens sideways"
# 
# def test_seats_count():
#   assert tešla.seats_count == 5
# 
#

#adding DocStrings to selected 3 functions of Tesla class

class Tesla:
    def __init__(self, model: str, color: str, autopilot: bool = False) -> None:
      """
      Constructs all the necessary attributes for the Tesla object.
      
      Parameters:
      ___________
        model: str
          model of the Tesla car
        color: str
          color of the Tesla model
        autopilot: bool = False
          shows whether the car has autopilot. If False, then no autopilot.
          If autopilot = True, then the car has autopilot.
      """

      self.__unlock_count = 0
      self.__model = model
      self.__color = color
      self.__battery_charge = 99.9
      self.__is_locked = True
      self.__seats_count = 5
      self.__autopilot = autopilot
      self.__open_doors = "Car is locked!"
      self.__efficiency = 0.3

    def welcome(self) -> str:
        raise NotImplementedError

    @property
    def getColor(self) -> str:
      """Takes color string and returns it"""
      return self.__color
    @property
    def getModel(self) -> str:
        return self.__model
    @property
    def seats_count(self) -> str:
        return self.__seats_count

    @seats_count.setter
    def seats_count(self, new_count: str) -> str:
        self.__seats_count = new_count

    def autopilot(self, obsticle: str) -> str:
        # COMPLETE THE FUNCION
        if self.__autopilot:
          return f"Tesla model {self.__model} avoids {obsticle}"
        return "Autopilot is not available"
    
    def unlock(self) -> str:
      self.__unlock_count = 1

    def lock(self) -> str:
      self.__unlock_count = 0

    def open_doors(self):
      if self.__unlock_count == 0:
        return "Car is locked!"
      else:
        return "Doors opens sideways"
        
    def check_battery_level(self) -> str:
        return f"Battery charge level is {self.__battery_charge}%"
    
    def charge_battery(self) -> str:
        self.__battery_charge = 100
        return f"Battery charge level is {self.__battery_charge}%"
    
    def drive(self, travel_range: float):
      """ Shows battery charge level for the planned trip """
      battery_discharge_percent = travel_range * self.__efficiency
      if self.__battery_charge - battery_discharge_percent >= 0:
        self.__battery_charge -= battery_discharge_percent
        return f"Battery charge level is {self.__battery_charge}%"
      else:
        return "Battery charge level is not sufficient"

Tesla.getColor.__doc__
Tesla.__doc__
Tesla.drive.__doc__

"""---

## Summary
You did a great job this lesson! You learned about software testing, gained knowledge of documentation and legal parts of software development. Now you not only know how to write code but also how to maintain it and represent it to other developers. Tomorrow we will talk about Python environments and you will learn how to create your own Python package!

## Further research
Reviewing code is a really important part of daily developer's workflow but good developers should also know how to write informative [Pull Requests](https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/about-pull-requests). You can start diving into this topic by reading [this](https://www.atlassian.com/blog/git/written-unwritten-guide-pull-requests) source. Also [here](https://medium.com/better-programming/how-to-make-a-perfect-pull-request-3578fb4c112) is also a pretty good TLDR on how to write good PRs.

---

## Instructor
### Questions

#### Unit Testing requires more time when initially developing a product.
+ True  
- False  

#### Unit Testing doesn't influence the architecture of a project.
+ True   
- False   

#### How many unit tests should you write?
+ Enough to have a high level of confidence with your project.  
- 100% of code coverage should be achieved.  
- At least 50% of code coverage should be achieved.  
- Enough to know that a user isn’t going to break your work on installation.  

#### Why does software needs a license?
+ To protect the intellectual property of its creator(s). 
- So that it doesn't break privacy laws. 
- This is how it is bought and sold. 

#### Microsoft Windows 10 is an example of application software. 
+ False  
- True  

#### Microsoft Word is an example of system software.
+ False  
- True  

#### Which one is ONE type of license?
+ Proprietary    
- Utility  
- Middleware  

#### Which of these licenses will run a server script to limit the number of users at any one time?
+ Network license  
- Application license  
- Enterprise license  

#### User interface refers to
+ How the software looks and feels to the user  
- How long the software takes to develop  
- What the user requires from the software  

#### Which of the following is NOT a reason why copyright law exists?
+ To ensure personal information and data is secured   
- Because intellectual property is protected  
- To prevent unauthorised copying of work  

#### Site license is another name for multiple-user license
+ False  
- True  

#### Clean code ____________.
+ Is easy to understand and easy to change  
- Is every developer's dream  
- Makes businesses happy  

#### The process of separating modules is called ____________.
+ Decoupling
- Rigidity
- Immobility

#### Software document can be defined as selected information that describes the development, operation, use and maintenance of computer software.
+ No  
- Yes  

#### There are 2 main types of software documentation, which are
+ User Document   
- Operation Document  
- Schedule Document  
+ Development Document  

#### Testing in software development cycle is about:
+ Evaluate performance of product  
- Review phase activities   
- Carry out system and software design   

#### Provide complete information is one of the criteria in writing effective software guidelines
+ Yes  
- No   

#### Tool you can use to test Python code
+ PyTest  
- Pandas  
- Unity  

#### Type hints:
+ Prevent unexpected types of inputs and outputs  
- Ensure that wrong data type is never passed  

#### Tests that replicates a user behavior with the software in a complete application environment are
+ End-to-end tests  
- Performance testing  
- Integration test
"""